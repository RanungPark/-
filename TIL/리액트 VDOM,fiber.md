### **리액트에서의 컴포넌트 렌더링 과정**

1. **컴포넌트를 호출하여 리액트 엘리먼트를 반환**:

- 리액트 컴포넌트(함수형 또는 클래스형 컴포넌트)가 호출되면, **리액트 엘리먼트**를 반환합니다. 이 엘리먼트는 **JSX**를 컴파일한 결과로, 일반 객체 형태로 나타나며 type, props, children 등의 속성을 가집니다.

2. **리액트 엘리먼트를 파이버 노드로 확장**:

- 반환된 리액트 엘리먼트는 **파이버 노드(Fiber Node)** 로 변환됩니다. 이 과정에서 리액트는 엘리먼트의 상태(state), props, 트리 구조(child, sibling, return) 등을 파이버 노드에 저장하며, 이는 향후 렌더링 최적화 및 업데이트에 활용됩니다.

3. **파이버 노드를 기반으로 VDOM에 반영**:

- 파이버 노드를 이용해 **가상 DOM(Virtual DOM)** 을 구성합니다. VDOM은 UI의 메모리 상에 있는 사본으로, 실제 DOM과의 차이를 계산하여 변화가 필요한 부분만 효율적으로 업데이트합니다. 이 과정에서 리액트는 **재조정(reconciliation)** 을 통해 최적의 업데이트를 수행합니다.

4. **실제 DOM에 반영**:

- VDOM과 실제 DOM의 차이를 계산한 후, 필요한 부분만 실제 DOM에 반영하는 과정이 이루어집니다. 이를 통해 화면에 UI가 그려지거나 업데이트됩니다.

### **리액트 엘리먼트**

리액트 엘리먼트는 UI를 구성하는 가장 작은 단위이며, 불변 객체로서 리액트가 UI를 어떻게 렌더링할지 설명합니다. 리액트 엘리먼트에는 두 가지 주요 유형이 있습니다.

1. **DOM 엘리먼트**

- 실제 HTML DOM과 유사한 객체로, HTML 태그를 사용하여 생성됩니다. 예를 들어 <div>나 <span> 같은 태그를 사용하여 생성한 엘리먼트입니다.
- 리액트에서 DOM 엘리먼트는 type (태그 이름), props (속성들), children (자식 엘리먼트)로 구성된 객체입니다.

2. **컴포넌트 엘리먼트**

- 리액트 컴포넌트를 나타내는 엘리먼트입니다. 컴포넌트 엘리먼트는 함수형 또는 클래스형 컴포넌트의 반환 값으로, 다시 DOM 엘리먼트나 다른 컴포넌트 엘리먼트를 렌더링합니다.
- 컴포넌트 엘리먼트도 type과 props, children을 가진 객체로, 리액트는 이를 이용해 해당 컴포넌트를 렌더링합니다.

### **hook 정보 포함 과정**

1. **리액트 엘리먼트는 hook에 대한 정보를 지니고 있지 않다.**

- 리액트 엘리먼트는 DOM 요소나 컴포넌트를 설명하는 **순수한 객체**입니다. 이 객체는 type, props, children 등의 속성을 가지며, hook과 관련된 정보를 직접적으로 포함하고 있지 않습니다.

2.  **hook에 대한 정보는 리액트 엘리먼트가 Fiber로 확장될 때 포함된다.**

- 리액트의 **Reconciler**는 리액트 엘리먼트를 받아서 이를 **Fiber 노드로 확장**합니다. 이 과정에서 리액트 컴포넌트의 상태, 라이프 사이클, hook에 대한 정보가 포함됩니다.
- hook은 컴포넌트가 렌더링될 때 실행되고, 이때 hook의 상태와 관련된 정보는 Fiber 노드 안에 저장됩니다.

3. **Reconciler가 리액트 엘리먼트를 Fiber로 확장한다.**

- 리액트 엘리먼트는 Reconciler에 의해 **Fiber 구조**로 변환됩니다. 이 Fiber 구조 안에는 컴포넌트의 상태, 라이프 사이클, hook 상태 등 렌더링과 관련된 모든 정보가 포함되며, 이를 바탕으로 컴포넌트가 어떻게 렌더링되고 업데이트되는지 결정됩니다.

### **DOM 엘리먼트와 컴포넌트 엘리먼트의 차이**

- **DOM 엘리먼트**는 리액트가 실제 HTML 태그를 어떻게 렌더링할지 설명하는 객체이고, **컴포넌트 엘리먼트**는 리액트 컴포넌트를 어떻게 렌더링할지 설명하는 객체입니다.
- 이 두 엘리먼트는 서로 독립적으로 존재할 수 있지만, 보통 컴포넌트 엘리먼트는 최종적으로 DOM 엘리먼트를 반환하며, 그 과정에서 여러 컴포넌트 엘리먼트들이 계층적으로 중첩될 수 있습니다.

### **파이버(Fiber)란?**

리액트의 **파이버(Fiber)** 는 리액트가 렌더링을 효율적으로 처리하기 위해 도입한 **재조정(reconciliation)** 알고리즘의 핵심 개념입니다. 이전의 **스택 기반 알고리즘**이 한 번에 전체 트리를 처리하는 방식이었지만, 파이버는 작업을 여러 조각으로 나누어, **비동기적으로** 작업을 처리할 수 있게 합니다. 이는 리액트가 UI 업데이트 시 **우선순위에 따라 작업을 나누고 중단/재개**할 수 있게 하여, 사용자 경험을 향상시키는 데 기여합니다.

### **파이버 노드의 역할**

- **파이버 노드(Fiber Node)** 는 리액트 컴포넌트나 DOM 노드의 각각의 인스턴스를 나타내는 객체입니다.
- 리액트의 **파이버 트리**는 실제로 이 파이버 노드들이 모여서 구성됩니다.
- 각 파이버 노드는 **상태(state)**, **props**, **라이프사이클 메서드**, **DOM 참조**와 같은 중요한 정보들을 포함하고 있습니다.

**파이버 노드의 구조**

파이버 노드는 다음과 같은 정보를 포함합니다:

1. **type**: 컴포넌트의 타입 (함수형 컴포넌트, 클래스형 컴포넌트, DOM 엘리먼트 등).
2. **props**: 해당 컴포넌트나 엘리먼트에 전달된 속성들.
3. **state**: 컴포넌트의 상태.
4. **child**, **sibling**, **return**: 파이버 노드 간의 트리 구조를 형성하는 링크.
5. **alternate**: 현재 트리의 이전 상태를 나타내는 연결(더블 버퍼링을 통해 빠른 업데이트 처리).

### **VDOM (Virtual DOM)**

**VDOM**은 리액트에서 UI 업데이트를 효율적으로 처리하기 위해 사용하는 메모리 상의 가상 DOM입니다. 리액트는 컴포넌트의 상태 변화에 따라 VDOM을 업데이트하고, 변경 사항을 실제 DOM에 반영합니다. 이는 성능 최적화를 위한 중요한 메커니즘입니다.

**더블 버블링 구조**

리액트의 렌더링 및 업데이트 구조는 **더블 버블링(Double Buffering)**과 비슷한 구조로 이해할 수 있습니다. 여기서는 두 가지 트리가 함께 사용됩니다:

- **Current Tree**: 현재 DOM에 마운트된 **Fiber Tree**입니다. 이는 실제 DOM과 일치하는 상태의 Fiber Tree입니다.
- **WorkInProgress Tree**: 현재 **render phase**에서 작업 중인 **Fiber Tree**입니다. 이 트리는 아직 실제 DOM에 적용되지 않았으며, **commit phase**가 완료되면 current tree로 전환됩니다.

**Fiber 구조와 렌더링 과정**

리액트 16부터 도입된 **Fiber 구조**는 렌더링과 업데이트 과정에서 우선순위를 조절할 수 있는 유연성을 제공합니다. Fiber 구조는 두 가지 주요 단계로 나뉩니다:

1. **Render Phase (렌더 단계)**

- **VDOM 재조정(Reconciliation)** 단계입니다. 이 단계에서는 컴포넌트의 변경 사항을 확인하고, 새롭게 추가된 요소, 수정된 요소, 삭제된 요소들을 파악합니다.
- **작업(WORK)** 이 **Scheduler**에 등록됩니다. 이 작업들은 리액트의 **Reconciler**가 컴포넌트 변경을 DOM에 반영하기 위해 수행하는 일입니다.
- 이 단계는 비동기적으로 실행되며, 리액트는 작업의 우선순위를 판단하고, 백그라운드에서 필요에 따라 작업을 나눠서 처리할 수 있습니다.

2. **Commit Phase (커밋 단계)**

- **VDOM을 실제 DOM에 적용하고, 라이프 사이클 메서드를 실행하는 단계**입니다.
- 이 단계는 일관성을 위해 **동기적**으로 실행됩니다. 즉, DOM 조작은 한꺼번에 이루어지며, 작업이 완료되면 리액트는 **콜 스택을 비우고**, 브라우저가 **페인트(paint)**를 시작할 수 있도록 합니다.
- 이 과정에서는 DOM 업데이트뿐만 아니라 컴포넌트의 componentDidMount, componentDidUpdate 등의 라이프 사이클 메서드가 실행됩니다.
